var ch_state;
(function (ch_state) {
    ch_state[ch_state["attack"] = 0] = "attack";
    ch_state[ch_state["hold"] = 1] = "hold";
    ch_state[ch_state["decay"] = 2] = "decay";
    ch_state[ch_state["releasing"] = 3] = "releasing";
})(ch_state || (ch_state = {}));
var sf_gen_id;
(function (sf_gen_id) {
    sf_gen_id[sf_gen_id["startAddrsOffset"] = 0] = "startAddrsOffset";
    sf_gen_id[sf_gen_id["endAddrsOffset"] = 1] = "endAddrsOffset";
    sf_gen_id[sf_gen_id["startloopAddrsOffset"] = 2] = "startloopAddrsOffset";
    sf_gen_id[sf_gen_id["endloopAddrsOffset"] = 3] = "endloopAddrsOffset";
    sf_gen_id[sf_gen_id["startAddrsCoarseOffset"] = 4] = "startAddrsCoarseOffset";
    sf_gen_id[sf_gen_id["modLfoToPitch"] = 5] = "modLfoToPitch";
    sf_gen_id[sf_gen_id["vibLfoToPitch"] = 6] = "vibLfoToPitch";
    sf_gen_id[sf_gen_id["modEnvToPitch"] = 7] = "modEnvToPitch";
    sf_gen_id[sf_gen_id["initialFilterFc"] = 8] = "initialFilterFc";
    sf_gen_id[sf_gen_id["initialFilterQ"] = 9] = "initialFilterQ";
    sf_gen_id[sf_gen_id["modLfoToFilterFc"] = 10] = "modLfoToFilterFc";
    sf_gen_id[sf_gen_id["modEnvToFilterFc"] = 11] = "modEnvToFilterFc";
    sf_gen_id[sf_gen_id["endAddrsCoarseOffset"] = 12] = "endAddrsCoarseOffset";
    sf_gen_id[sf_gen_id["modLfoToVolume"] = 13] = "modLfoToVolume";
    sf_gen_id[sf_gen_id["unused1"] = 14] = "unused1";
    sf_gen_id[sf_gen_id["chorusEffectsSend"] = 15] = "chorusEffectsSend";
    sf_gen_id[sf_gen_id["reverbEffectsSend"] = 16] = "reverbEffectsSend";
    sf_gen_id[sf_gen_id["pan"] = 17] = "pan";
    sf_gen_id[sf_gen_id["unused2"] = 18] = "unused2";
    sf_gen_id[sf_gen_id["unused3"] = 19] = "unused3";
    sf_gen_id[sf_gen_id["unused4"] = 20] = "unused4";
    sf_gen_id[sf_gen_id["delayModLFO"] = 21] = "delayModLFO";
    sf_gen_id[sf_gen_id["freqModLFO"] = 22] = "freqModLFO";
    sf_gen_id[sf_gen_id["delayVibLFO"] = 23] = "delayVibLFO";
    sf_gen_id[sf_gen_id["freqVibLFO"] = 24] = "freqVibLFO";
    sf_gen_id[sf_gen_id["delayModEnv"] = 25] = "delayModEnv";
    sf_gen_id[sf_gen_id["attackModEnv"] = 26] = "attackModEnv";
    sf_gen_id[sf_gen_id["holdModEnv"] = 27] = "holdModEnv";
    sf_gen_id[sf_gen_id["decayModEnv"] = 28] = "decayModEnv";
    sf_gen_id[sf_gen_id["sustainModEnv"] = 29] = "sustainModEnv";
    sf_gen_id[sf_gen_id["releaseModEnv"] = 30] = "releaseModEnv";
    sf_gen_id[sf_gen_id["keynumToModEnvHold"] = 31] = "keynumToModEnvHold";
    sf_gen_id[sf_gen_id["keynumToModEnvDecay"] = 32] = "keynumToModEnvDecay";
    sf_gen_id[sf_gen_id["delayVolEnv"] = 33] = "delayVolEnv";
    sf_gen_id[sf_gen_id["attackVolEnv"] = 34] = "attackVolEnv";
    sf_gen_id[sf_gen_id["holdVolEnv"] = 35] = "holdVolEnv";
    sf_gen_id[sf_gen_id["decayVolEnv"] = 36] = "decayVolEnv";
    sf_gen_id[sf_gen_id["sustainVolEnv"] = 37] = "sustainVolEnv";
    sf_gen_id[sf_gen_id["releaseVolEnv"] = 38] = "releaseVolEnv";
    sf_gen_id[sf_gen_id["keynumToVolEnvHold"] = 39] = "keynumToVolEnvHold";
    sf_gen_id[sf_gen_id["keynumToVolEnvDecay"] = 40] = "keynumToVolEnvDecay";
    sf_gen_id[sf_gen_id["instrument"] = 41] = "instrument";
    sf_gen_id[sf_gen_id["reserved1"] = 42] = "reserved1";
    sf_gen_id[sf_gen_id["keyRange"] = 43] = "keyRange";
    sf_gen_id[sf_gen_id["velRange"] = 44] = "velRange";
    sf_gen_id[sf_gen_id["startloopAddrsCoarse"] = 45] = "startloopAddrsCoarse";
    sf_gen_id[sf_gen_id["keynum"] = 46] = "keynum";
    sf_gen_id[sf_gen_id["velocity"] = 47] = "velocity";
    sf_gen_id[sf_gen_id["initialAttenuation"] = 48] = "initialAttenuation";
    sf_gen_id[sf_gen_id["reserved2"] = 49] = "reserved2";
    sf_gen_id[sf_gen_id["endloopAddrsCoarse"] = 50] = "endloopAddrsCoarse";
    sf_gen_id[sf_gen_id["coarseTune"] = 51] = "coarseTune";
    sf_gen_id[sf_gen_id["fineTune"] = 52] = "fineTune";
    sf_gen_id[sf_gen_id["sampleID"] = 53] = "sampleID";
    sf_gen_id[sf_gen_id["sampleModes"] = 54] = "sampleModes";
    sf_gen_id[sf_gen_id["reserved3"] = 55] = "reserved3";
    sf_gen_id[sf_gen_id["scaleTuning"] = 56] = "scaleTuning";
    sf_gen_id[sf_gen_id["exclusiveClass"] = 57] = "exclusiveClass";
    sf_gen_id[sf_gen_id["overridingRootKey"] = 58] = "overridingRootKey";
    sf_gen_id[sf_gen_id["unused5"] = 59] = "unused5";
    sf_gen_id[sf_gen_id["endOper"] = 60] = "endOper";
})(sf_gen_id || (sf_gen_id = {}));
var mergeTypes;
(function (mergeTypes) {
    mergeTypes[mergeTypes["SET_INST_DEFAULT"] = 0] = "SET_INST_DEFAULT";
    mergeTypes[mergeTypes["SET_INST"] = 1] = "SET_INST";
    mergeTypes[mergeTypes["SET_PBAG"] = 2] = "SET_PBAG";
    mergeTypes[mergeTypes["SET_PBAGDEFAULT"] = 3] = "SET_PBAGDEFAULT";
})(mergeTypes || (mergeTypes = {}));
var LOOPMODES;
(function (LOOPMODES) {
    LOOPMODES[LOOPMODES["NO_LOOP"] = 0] = "NO_LOOP";
    LOOPMODES[LOOPMODES["CONTINUOUS_LOOP"] = 1] = "CONTINUOUS_LOOP";
    LOOPMODES[LOOPMODES["NO_LOOP_EQ"] = 2] = "NO_LOOP_EQ";
    LOOPMODES[LOOPMODES["LOOP_DURATION_PRESS"] = 3] = "LOOP_DURATION_PRESS";
})(LOOPMODES || (LOOPMODES = {}));
const generatorNames = `#define SFGEN_startAddrsOffset         0
#define SFGEN_endAddrsOffset           1
#define SFGEN_startloopAddrsOffset     2
#define SFGEN_endloopAddrsOffset       3
#define SFGEN_startAddrsCoarseOffset   4
#define SFGEN_modLfoToPitch            5
#define SFGEN_vibLfoToPitch            6
#define SFGEN_modEnvToPitch            7
#define SFGEN_initialFilterFc          8
#define SFGEN_initialFilterQ           9
#define SFGEN_modLfoToFilterFc         10
#define SFGEN_modEnvToFilterFc         11
#define SFGEN_endAddrsCoarseOffset     12
#define SFGEN_modLfoToVolume           13
#define SFGEN_unused1                  14
#define SFGEN_chorusEffectsSend        15
#define SFGEN_reverbEffectsSend        16
#define SFGEN_pan                      17
#define SFGEN_unused2                  18
#define SFGEN_unused3                  19
#define SFGEN_unused4                  20
#define SFGEN_delayModLFO              21
#define SFGEN_freqModLFO               22
#define SFGEN_delayVibLFO              23
#define SFGEN_freqVibLFO               24
#define SFGEN_delayModEnv              25
#define SFGEN_attackModEnv             26
#define SFGEN_holdModEnv               27
#define SFGEN_decayModEnv              28
#define SFGEN_sustainModEnv            29
#define SFGEN_releaseModEnv            30
#define SFGEN_keynumToModEnvHold       31
#define SFGEN_keynumToModEnvDecay      32
#define SFGEN_delayVolEnv              33
#define SFGEN_attackVolEnv             34
#define SFGEN_holdVolEnv               35
#define SFGEN_decayVolEnv              36
#define SFGEN_sustainVolEnv            37
#define SFGEN_releaseVolEnv            38
#define SFGEN_keynumToVolEnvHold       39
#define SFGEN_keynumToVolEnvDecay      40
#define SFGEN_instrument               41
#define SFGEN_reserved1                42
#define SFGEN_keyRange                 43
#define SFGEN_velRange                 44
#define SFGEN_startloopAddrsCoarse     45
#define SFGEN_keynum                   46
#define SFGEN_velocity                 47
#define SFGEN_initialAttenuation       48
#define SFGEN_reserved2                49
#define SFGEN_endloopAddrsCoarse       50
#define SFGEN_coarseTune               51
#define SFGEN_fineTune                 52
#define SFGEN_sampleID                 53
#define SFGEN_sampleModes              54
#define SFGEN_reserved3                55
#define SFGEN_scaleTuning              56
#define SFGEN_exclusiveClass           57
#define SFGEN_overridingRootKey        58
#define SFGEN_unused5                  59
#define SFGEN_endOper                  60`
    .trim()
    .split('\n')
    .map((line) => line.split(/\s+/)[1])
    .map((token) => token.replace('SFGEN_', ''));

/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
class SFGenerator {
    constructor(_operator, int16) {
        this._operator = _operator;
        this.int16 = int16;
        this.from = 0;
        this.ibagId = -1;
        this.pbagId = -1;
    }
    add(modgen) {
        this.int16 += modgen.int16;
    }
    get operator() {
        return this._operator;
    }
    get range() {
        return { lo: this.int16 & 0x7f, hi: (this.int16 >> 8) & 0xff };
    }
    get u16() {
        return this.int16 & 0x0ff0; // | (this.hi << 8);
    }
    get s16() {
        return this.int16;
    }
    set s16(val) {
        this.int16 += val;
    }
}
function cent2hz(centiHz) {
    return 8.176 * Math.pow(2, centiHz / 1200.0);
}
function timecent2sec(timecent) {
    return Math.pow(2, timecent / 1200.0);
}
function centidb2gain(centibel) {
    return Math.pow(10, centibel / 200);
}
class SFZone {
    constructor(ids) {
        this.keyRange = { lo: -1, hi: 129 };
        this.velRange = { lo: -1, hi: 129 };
        this._shdr = {
            name: 'init',
            start: 0,
            end: 0,
            startLoop: 0,
            endLoop: 0,
            originalPitch: 60,
            sampleRate: -1,
            pitchCorrection: 0,
            sampleLink: 0,
            sampleType: 0,
        };
        this.sampleOffsets = [0, 0, 0, 0];
        this._modLFO = SFZone.defaultLFO;
        this._vibrLFO = SFZone.defaultLFO;
        this._modEnv = SFZone.defaultEnv;
        this._volEnv = SFZone.defaultEnv;
        this.lpf = { cutoff: 0, q: -1 };
        this.chorus = 0; /* chrous web %/10 */ /* chrous web %/10 */
        this.reverbSend = 0; /* percent of signal to send back.. in 0.1% units*/
        this.pan = -1; /* shift to right percent */
        this.attenuate = 0; /*db in attentuation*/
        this.instrumentID = -1;
        this._rootkey = -1;
        this.tuning = 0;
        this.sampleMode = LOOPMODES.CONTINUOUS_LOOP;
        this.sampleID = -1;
        this.generators = [];
        if (ids) {
            if (ids.pbagId)
                this.pbagId = ids.pbagId;
            if (ids.ibagId)
                this.ibagId = ids.ibagId;
        }
    }
    serialize() {
        return {
            ...this,
            modLFO: this._modLFO,
            vibrLFO: this._vibrLFO,
            modEnv: this._modEnv,
            volEnv: this._volEnv,
            sample: this.sample,
        };
    }
    get modLFO() {
        if (this._modLFO) {
            this._modLFO = SFZone.defaultLFO;
        }
        return this._modLFO;
    }
    set modLFO(value) {
        this._modLFO = value;
    }
    get vibrLFO() {
        return this._vibrLFO;
    }
    set vibrLFO(value) {
        this._vibrLFO = value;
    }
    get modEnv() {
        return this._modEnv;
    }
    set modEnv(value) {
        this._modEnv = value;
    }
    get volEnv() {
        if (!this._modEnv) {
            this._modEnv = SFZone.defaultEnv;
        }
        return this._volEnv;
    }
    set volEnv(value) {
        this._volEnv = value;
    }
    get scaleTuning() {
        return this.generators[sf_gen_id.scaleTuning]
            ? this.generators[sf_gen_id.scaleTuning].s16
            : 0;
    }
    get keynumToVolEnvDecay() {
        return this.generators[sf_gen_id.keynumToVolEnvDecay]
            ? this.generators[sf_gen_id.keynumToVolEnvDecay].s16
            : 0;
    }
    get rootkey() {
        return this._rootkey > -1 ? this._rootkey : this.sample.originalPitch;
    }
    set rootkey(value) {
        this._rootkey = value;
    }
    get pitch() {
        return this.rootkey * 100 + this.tuning - this.sample.pitchCorrection;
    }
    set sample(shdr) {
        this._shdr = shdr;
    }
    get sample() {
        return {
            ...this._shdr,
            start: this._shdr.start + this.sampleOffsets[0],
            end: this._shdr.end + this.sampleOffsets[1],
            startLoop: this._shdr.startLoop + this.sampleOffsets[2],
            endLoop: this._shdr.endLoop + this.sampleOffsets[3],
        };
    }
    mergeWith(zoneb, from = 0) {
        for (const g of Object.values(zoneb.generators)) {
            this.applyGenVal(g, from);
        }
    }
    setVal(gen) {
        this.generators[gen.operator] = gen;
    }
    increOrSet(gen) {
        if (!this.generators[gen.operator])
            this.generators[gen.operator] = gen;
        else
            this.generators[gen.operator].s16 += gen.s16;
    }
    applyGenVals() {
        this.generators.forEach((g) => this.applyGenVal(g, -1));
    }
    applyGenVal(gen, from) {
        switch (gen.operator) {
            case startAddrsOffset:
                this.sampleOffsets[0] += gen.s16;
                break;
            case endAddrsOffset:
                this.sampleOffsets[1] += gen.s16;
                break;
            case startloopAddrsOffset:
                this.sampleOffsets[2] += gen.s16;
                break;
            case endloopAddrsOffset:
                this.sampleOffsets[3] += gen.s16;
                break;
            case startAddrsCoarseOffset:
                this.sampleOffsets[0] += gen.s16 << 15;
                break;
            case modLfoToPitch:
                this.modLFO.effects.pitch = gen.s16;
                break;
            case vibLfoToPitch:
                this.vibrLFO.effects.pitch = gen.s16;
                break;
            case modEnvToPitch:
                this.modEnv.effects.pitch = gen.s16;
                break;
            case initialFilterFc:
                this.lpf.cutoff = gen.s16;
                break;
            case initialFilterQ:
                this.lpf.q = gen.s16;
                break;
            case modLfoToFilterFc:
                this.modLFO.effects.filter = gen.s16;
                break;
            case modEnvToFilterFc:
                this.modEnv.effects.filter = gen.s16;
                break;
            case endAddrsCoarseOffset:
                this.sampleOffsets[1] += gen.s16 << 15;
                break;
            case modLfoToVolume:
                this.modLFO.effects.volume = gen.s16;
                break;
            case unused1:
            case chorusEffectsSend:
                this.chorus = gen.s16;
                break;
            case reverbEffectsSend:
                this.reverbSend = gen.s16;
                break;
            case pan:
                this.pan = gen.s16;
                break;
            case unused2:
            case unused3:
            case unused4:
                break;
            case delayModLFO:
                this.modLFO.delay = gen.s16;
                break;
            case freqModLFO:
                this.modLFO.freq = gen.s16;
                break;
            case delayVibLFO:
                this.vibrLFO.delay = gen.s16;
                break;
            case freqVibLFO:
                this.vibrLFO.freq = gen.s16;
                break;
            case delayModEnv:
                this.modEnv.phases.delay = gen.s16;
                break;
            case attackModEnv:
                this.modEnv.phases.attack = gen.s16;
                break;
            case holdModEnv:
                this.modEnv.default = false;
                this.modEnv.phases.hold = gen.s16; // timecent2sec(gen.s16);
                break;
            case decayModEnv:
                this.volEnv.default = false;
                this.modEnv.phases.decay = gen.s16; //timecent2sec(gen.s16);
                break;
            case sustainModEnv /* percent of fullscale*/:
                this.modEnv.default = false;
                this.modEnv.sustain = gen.s16;
                break;
            case releaseModEnv:
                this.modEnv.phases.release = gen.s16;
                break;
            case keynumToModEnvHold:
            case keynumToModEnvDecay:
                break;
            case delayVolEnv:
                this.volEnv.phases.delay = gen.s16;
                break;
            case attackVolEnv /*This is the time, in absolute timecents, from the end of the Volume
            Envelope Delay Time until the point at which the Volume Envelope
            value reaches its peak. Note that the attack is “convex”; the curve is
            nominally such that when applied to the decibel volume parameter, the
            result is linear in amplitude. A value of 0 indicates a 1 second attack
            time. A negative value indicates a time less than one second; a positive
            value a time longer than one second. The most negative number (-
            32768) conventionally indicates instantaneous attack. For example, an
            attack time of 10 msec would be 1200log2(.01) = -7973.*/:
                this.volEnv.phases.attack = gen.s16;
                break;
            case holdVolEnv:
                this.volEnv.phases.hold = gen.s16;
                break;
            case decayVolEnv:
                this.volEnv.default = false;
                this.volEnv.phases.decay = gen.s16; //timecent2sec(gen.s16);
                break;
            /** \']
            
            http://www.synthfont.com/SFSPEC21.PDF  is the decrease in level, expressed in centibels, to which the
            Volume Envelope value ramps during the decay phase. For the Volume
            Envelope, the sustain level is best expressed in centibels of attenuation
            from full scale. A value of 0 indicates the sustain level is full level; this
            implies a zero duration of decay phase regardless of decay time. A
            positive value indicates a decay to the corresponding level. Values less
            than zero are to be interpreted as zero; conventionally 1000 indicates
            full attenuation. For example, a sustain level which corresponds to an
      absolute value 12dB below of peak would be 120. */
            case sustainVolEnv:
                this.volEnv.sustain = gen.s16;
                this.volEnv.default = false;
                break;
            /*This is the time, in absolute timecents, for a 100% change in the
      Volume Envelope value during release phase. For the Volume
      Envelope, the release phase linearly ramps toward zero from the current
      level, causing a constant dB change for each time unit. If the current
      level were full scale, the Volume Envelope Release Time would be the
      time spent in release phase until 100dB attenuation were reached. A
      value of 0 indicates a 1-second decay time for a release from full level.
      SoundFont 2.01 Technical Specification - Page 45 - 08/05/98 12:43 PM
      A negative value indicates a time less than one second; a positive value
      a time longer than one second.  http://www.synthfont.com/SFSPEC21.PDF For example, . For example, a release time of 10 msec
      would be 1200log2(.01) = -7973. */
            case releaseVolEnv:
                this.volEnv.phases.release = gen.s16; //timecent2sec(gen.s16);
                break;
            case keynumToVolEnvHold:
            case keynumToVolEnvDecay:
                break;
            case instrument:
                this.instrumentID = gen.s16;
                break;
            case reserved1:
                break;
            case keyRange:
                this.keyRange.lo = Math.max(gen.range.lo, this.keyRange.lo);
                this.keyRange.hi = Math.min(gen.range.hi, this.keyRange.hi);
                break;
            case velRange:
                this.velRange = gen.range;
                break;
            case startloopAddrsCoarse:
                this.sampleOffsets[2] += gen.s16 << 15;
                break;
            case keynum:
                break;
            case velocity:
                break;
            case initialAttenuation:
                this.attenuate = gen.s16;
                break;
            case reserved2:
                break;
            case endloopAddrsCoarse:
                this.sampleOffsets[3] += gen.s16 << 15;
                // this._shdr.endLoop += 15 << gen.s16;
                break;
            case coarseTune:
                this.tuning += gen.s16 * 100; //semitone
                break;
            case fineTune:
                this.tuning += gen.s16; //tone
                break;
            case sampleID:
                //onsole.log('apply sample ' + gen.s16 + 'cur ');
                if (this.sampleID != -1) ;
                this.sampleID = gen.s16;
                break;
            case sampleModes:
                break;
            case reserved3:
                break;
            case scaleTuning:
                break;
            case exclusiveClass:
                break;
            case overridingRootKey:
                if (gen.s16 > -1)
                    this.rootkey = gen.s16;
                break;
            case unused5:
                break;
            case endOper:
                break;
            default:
                throw 'unexpected operator';
        }
        gen.from = from || -1;
        if (from != -1)
            this.generators.push(gen);
    }
}
SFZone.defaultEnv = {
    default: true,
    phases: {
        decay: -1000,
        attack: -12000,
        delay: -12000,
        release: -3000,
        hold: -12000,
    },
    sustain: 300,
    effects: { pitch: 0, filter: 0, volume: 0 },
};
SFZone.defaultLFO = {
    delay: 0,
    freq: 1,
    effects: { pitch: 0, filter: 0, volume: 0 },
};
const { startAddrsOffset, endAddrsOffset, startloopAddrsOffset, endloopAddrsOffset, startAddrsCoarseOffset, modLfoToPitch, vibLfoToPitch, modEnvToPitch, initialFilterFc, initialFilterQ, modLfoToFilterFc, modEnvToFilterFc, endAddrsCoarseOffset, modLfoToVolume, unused1, chorusEffectsSend, reverbEffectsSend, pan, unused2, unused3, unused4, delayModLFO, freqModLFO, delayVibLFO, freqVibLFO, delayModEnv, attackModEnv, holdModEnv, decayModEnv, sustainModEnv, releaseModEnv, keynumToModEnvHold, keynumToModEnvDecay, delayVolEnv, attackVolEnv, holdVolEnv, decayVolEnv, sustainVolEnv, releaseVolEnv, keynumToVolEnvHold, keynumToVolEnvDecay, instrument, reserved1, keyRange, velRange, startloopAddrsCoarse, keynum, velocity, initialAttenuation, reserved2, endloopAddrsCoarse, coarseTune, fineTune, sampleID, sampleModes, reserved3, scaleTuning, exclusiveClass, overridingRootKey, unused5, endOper, } = sf_gen_id;

class PDTA {
    constructor(r) {
        this.phdr = [];
        this.pbag = [];
        this.pgen = [];
        this.pmod = [];
        this.iheaders = [];
        this.igen = [];
        this.imod = [];
        this.ibag = [];
        this.shdr = [];
        this.findPreset = (pid, bank_id = 0, key = -1, vel = -1) => {
            const [phdr, pbag, shdr] = [this.phdr, this.pbag, this.shdr];
            let phd, i = 0;
            for (i = 0; i < phdr.length - 1; i++) {
                if (phdr[i].presetId != pid || phdr[i].bankId != bank_id) {
                    continue;
                }
                phd = phdr[i];
                break;
            }
            if (!phd)
                return [];
            const presetDefault = pbag[phd.pbagIndex];
            const pbagEnd = phdr[i + 1].pbagIndex;
            return pbag
                .slice(phd.pbagIndex, pbagEnd)
                .filter((pbg) => pbg.pzone.instrumentID >= 0)
                .filter((pbg) => keyVelInRange(pbg.pzone, key, vel))
                .map((pbg) => {
                const { defaultBg, izones } = this.findInstrument(pbg.pzone.instrumentID, key, vel);
                return izones.map((iz) => makeRuntime(iz, defaultBg, pbg, presetDefault.pzone, shdr[iz.sampleID]));
            })
                .flat();
        };
        this.findInstrument = (instId, key = -1, vel = -1) => {
            const [ibag, iheaders] = [this.ibag, this.iheaders];
            const ihead = iheaders[instId];
            return {
                inst: ihead,
                defaultBg: ibag[ihead.iBagIndex].izone,
                izones: ibag
                    .slice(ihead.iBagIndex, iheaders[instId + 1].iBagIndex)
                    .filter((ibg) => keyVelInRange(ibg.izone, key, vel))
                    .filter((ibg) => ibg.izone.sampleID > -1 && this.shdr[ibg.izone.sampleID])
                    .map((ibg) => ibg.izone),
            };
        };
        let n = 0;
        do {
            const ShdrLength = 46;
            const imodLength = 10;
            const phdrLength = 38;
            const pbagLength = 4;
            const pgenLength = 4, igenLength = 4;
            const pmodLength = 10;
            const instLength = 22;
            const sectionName = r.read32String();
            const sectionSize = r.get32();
            console.log(sectionName, sectionSize);
            switch (sectionName) {
                case 'phdr':
                    for (let i = 0; i < sectionSize; i += phdrLength) {
                        const phdrItem = {
                            name: r.readNString(20),
                            presetId: r.get16(),
                            bankId: r.get16(),
                            pbagIndex: r.get16(),
                            misc: [r.get32(), r.get32(), r.get32()],
                            pbags: [],
                            insts: [],
                            _defaultBag: -1,
                            get defaultBag() {
                                return this._defaultBag > -1 ? this._defaultBag : this.pbags[0];
                            },
                            set defaultBag(value) {
                                this._defaultBag = value;
                            },
                        };
                        this.phdr.push(phdrItem);
                    }
                    break;
                case 'pbag':
                    for (let i = 0; i < sectionSize; i += pbagLength) {
                        this.pbag.push({
                            pgen_id: r.get16(),
                            pmod_id: r.get16(),
                            pzone: new SFZone({ pbagId: i }),
                        });
                    }
                    break;
                case 'pgen': {
                    let pgenId = 0, pbagId = 0, phdrId = 0;
                    for (; pgenId < sectionSize / pgenLength; pgenId++) {
                        const opid = r.get8();
                        r.get8();
                        const v = r.getS16();
                        const pg = new SFGenerator(opid, v);
                        this.pgen.push(pg);
                        if (pg.operator == 60)
                            break;
                        this.pbag[pbagId].pzone.applyGenVal(pg, pgenId);
                        if (this.pbag[pbagId + 1] &&
                            pgenId >= this.pbag[pbagId + 1].pgen_id - 1) {
                            if (pbagId >= this.phdr[phdrId + 1].pbagIndex) {
                                phdrId++;
                            }
                            this.addPbagToPreset(pbagId, phdrId);
                            pbagId++;
                        }
                    }
                    break;
                }
                case 'pmod':
                    for (let i = 0; i < sectionSize; i += pmodLength) {
                        this.pmod.push({
                            src: r.get16(),
                            dest: r.get16(),
                            amt: r.get16(),
                            amtSrc: r.get16(),
                            transpose: r.get16(),
                        });
                    }
                    break;
                case 'inst':
                    for (let i = 0; i < sectionSize; i += instLength) {
                        this.iheaders.push({
                            name: r.readNString(20),
                            iBagIndex: r.get16(),
                            ibags: [],
                            defaultIbag: -1,
                        });
                    }
                    break;
                case 'ibag': {
                    let ibginst = 0;
                    for (let i = 0; i < sectionSize; i += pbagLength) {
                        if (this.iheaders[ibginst + 1] &&
                            i >= this.iheaders[ibginst + 1].iBagIndex)
                            ibginst++;
                        this.ibag.push({
                            igen_id: r.get16(),
                            imod_id: r.get16(),
                            izone: new SFZone({ ibagId: i }),
                        });
                        this.psh(ibginst, i, pbagLength);
                    }
                    //.push({ igen_id: -1, imod_id: 0, izone: new SFZone() });
                    this.ibag.push({ igen_id: -1, imod_id: 0, izone: new SFZone() });
                    break;
                }
                case 'igen': {
                    let ibagId = 0;
                    for (let igenId = 0; igenId < sectionSize / igenLength; igenId++) {
                        const opid = r.get8() | (r.get8() << 8);
                        if (opid == -1)
                            break;
                        const v = r.getS16();
                        const gen = new SFGenerator(opid, v);
                        this.igen.push(gen);
                        if (gen.operator === 60)
                            break;
                        this.ibag[ibagId].izone.applyGenVal(gen);
                        if (igenId >= this.ibag[ibagId + 1].igen_id - 1) {
                            ibagId++;
                        }
                    }
                    break;
                }
                case 'imod':
                    for (let i = 0; i < sectionSize; i += imodLength) {
                        this.imod.push({
                            src: r.get16(),
                            dest: r.get16(),
                            amt: r.get16(),
                            amtSrc: r.get16(),
                            transpose: r.get16(),
                        });
                    }
                    break;
                case 'shdr':
                    for (let i = 0; i < sectionSize; i += ShdrLength ///20 + 4 * 5 + 1 + 1 + 4)
                    ) {
                        this.shdr.push({
                            name: r.readNString(20),
                            start: r.get32(),
                            end: r.get32(),
                            startLoop: r.get32(),
                            endLoop: r.get32(),
                            sampleRate: r.get32(),
                            originalPitch: r.get8(),
                            pitchCorrection: r.get8(),
                            sampleLink: r.get16(),
                            sampleType: r.get16(),
                        });
                    }
                    break;
            }
        } while (n++ <= 9);
    }
    addPbagToPreset(pbagId, phdrId) {
        if (this.pbag[pbagId].pzone.instrumentID == -1) {
            if (this.phdr[phdrId].defaultBag == -1)
                this.phdr[phdrId].defaultBag = pbagId;
        }
        else {
            this.phdr[phdrId]?.pbags.push(pbagId);
            this.phdr[phdrId]?.insts.push(this.pbag[pbagId].pzone.instrumentID);
        }
    }
    psh(ibginst, i, pbagLength) {
        this.iheaders[ibginst].ibags &&
            this.iheaders[ibginst].ibags?.push(i / pbagLength);
    }
    getIbagZone(ibagId) {
        return this.ibag[ibagId] && this.ibag[ibagId].izone;
    }
}
function makeRuntime(izone, instDefault, pbg, defaultPbag, shr) {
    const output = new SFZone();
    for (let i = 0; i < 60; i++) {
        if (izone.generators[i]) {
            output.setVal(izone.generators[i]);
        }
        else if (instDefault && instDefault.generators[i]) {
            output.setVal(instDefault.generators[i]);
        }
        if (pbg.pzone.generators[i]) {
            output.increOrSet(pbg.pzone.generators[i]);
        }
        else if (defaultPbag && defaultPbag.generators[i]) {
            output.increOrSet(defaultPbag.generators[i]);
        }
    }
    output.applyGenVals();
    output.sample = shr;
    return output;
}
function keyVelInRange(zone, key, vel) {
    return ((key < 0 || (zone.keyRange.lo <= key && zone.keyRange.hi >= key)) &&
        (vel < 0 || (zone.velRange.lo <= vel && zone.velRange.hi >= vel)));
}

function readAB(arb) {
    const u8b = new Uint8Array(arb);
    let _offset = 0;
    function get8() {
        return u8b[_offset++];
    }
    function getStr(n) {
        let str = '';
        let nullterm = 0;
        for (let i = 0; i < n; i++) {
            const c = get8();
            if (c == 0x00)
                nullterm = 1;
            if (nullterm == 0)
                str += String.fromCharCode(c);
        }
        return str;
    }
    function get32() {
        return get8() | (get8() << 8) | (get8() << 16) | (get8() << 24);
    }
    const get16 = () => get8() | (get8() << 8);
    const getS16 = () => {
        const u16 = get16();
        if (u16 & 0x8000)
            return -0x10000 + u16;
        else
            return u16;
    };
    const readN = (n) => {
        const ret = u8b.slice(_offset, n);
        _offset += n;
        return ret;
    };
    function varLenInt() {
        let n = get8();
        while (n & 0x80) {
            n = get8();
        }
        return n;
    }
    const skip = (n) => {
        _offset = _offset + n;
    };
    const read32String = () => getStr(4);
    const readNString = (n) => getStr(n);
    return {
        skip,
        get8,
        get16,
        getS16,
        readN,
        read32String,
        varLenInt,
        get32,
        readNString,
        get offset() {
            return _offset;
        },
        set offset(n) {
            _offset = n;
        },
    };
}
// const r = readAB([1, 2, 3, 4, 4, 4, 4, 5, 5, 2, 3, 3, 4]);
// r.get16();
// r.get8();
// r.read32String();
// console.log(r.offset);

class SF2File {
    constructor(ab) {
        const r = readAB(ab);
        console.assert(r.read32String() == "RIFF");
        let size = r.get32();
        console.assert(r.read32String() == "sfbk");
        console.assert(r.read32String() == "LIST");
        size -= 64;
        do {
            const sectionSize = r.get32();
            const section = r.read32String();
            size = size - sectionSize;
            if (section === "pdta") {
                this.pdta = new PDTA(r);
            }
            else if (section === "sdta") {
                console.assert(r.read32String() == "smpl");
                const nsamples = (sectionSize - 4) / 2;
                const uint8s = r.readN(sectionSize - 4);
                const floatArr = new SharedArrayBuffer(uint8s.byteLength * 2);
                const dv2 = new DataView(floatArr);
                const dv = new DataView(uint8s.buffer);
                for (let i = 0; i < dv.byteLength / 2 - 1; i++) {
                    dv2.setFloat32(i * 4, dv.getInt16(2 * i, true) / 0x7fff, true);
                }
                function iterate(zone, key, outputSampleRate, length = 48000 * 2) {
                    const data = new Float32Array(floatArr);
                    const { start, end, startLoop, endLoop } = zone.sample;
                    const loop = [startLoop - start, endLoop - start];
                    const pitchRatio = (Math.pow(2, (key * 100 - zone.pitch) / 1200) * zone.sample.sampleRate) /
                        outputSampleRate;
                    function* shift() {
                        let pos = 0x00;
                        let n = 0;
                        let shift = 0.0;
                        while (n++ < length) {
                            yield data[pos];
                            shift = shift + pitchRatio;
                            while (shift >= 1) {
                                shift--;
                                pos++;
                            }
                            if (pos >= loop[1])
                                pos = loop[0];
                        }
                        return data[pos];
                    }
                    return shift();
                }
                this.sdta = {
                    nsamples,
                    data: uint8s,
                    floatArr: floatArr,
                    iterator: iterate,
                };
            }
            else {
                r.skip(sectionSize);
            }
        } while (size > 0);
    }
}
SF2File.fromURL = async (url) => {
    return new SF2File(await (await fetch(url)).arrayBuffer());
};

async function sfbkstream(url) {
    const ab = await (await fetch(url, { headers: { Range: 'bytes=0-6400' } })).arrayBuffer();
    const [preample, r] = skipToSDTA(ab);
    const sdtaSize = r.get32();
    const stdstart = r.offset + 8;
    const pdtastart = stdstart + sdtaSize + 4;
    const rangeHeader = {
        headers: {
            Range: 'bytes=' + stdstart + '-' + pdtastart,
        },
    };
    const pdtaHeader = {
        headers: { Range: 'bytes=' + pdtastart + '-' },
    };
    const { readable, writable } = new TransformStream();
    (await fetch(url, rangeHeader)).body.pipeTo(writable);
    return {
        nsamples: (pdtastart - stdstart) / 2,
        sdtaStream: readable,
        infos: preample,
        pdtaBuffer: new Uint8Array(await (await fetch(url, pdtaHeader)).arrayBuffer()),
    };
}
function skipToSDTA(ab) {
    const infosection = new Uint8Array(ab);
    const r = readAB(infosection);
    const [riff, filesize, sig, list] = [
        r.readNString(4),
        r.get32(),
        r.readNString(4),
        r.readNString(4),
    ];
    console.assert(riff == 'RIFF' && sig == 'sfbk');
    let infosize = r.get32();
    console.log(r.readNString(4), filesize, list, r.offset);
    console.log(infosize, r.offset);
    const infos = [];
    while (infosize >= 8) {
        const [section, size] = [r.readNString(4), r.get32()];
        infos.push({ section, text: r.readNString(size) });
        infosize = infosize - 8 - size;
    }
    console.assert(r.readNString(4) == 'LIST');
    return [infos, r];
}

export { LOOPMODES, PDTA, SF2File, SFGenerator, SFZone, cent2hz, centidb2gain, ch_state, generatorNames, mergeTypes, sf_gen_id, sfbkstream, timecent2sec };
